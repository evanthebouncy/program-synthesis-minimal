---
layout: post
title:  "what will you find here"
sticky: true
hidden: true
---

# so, you want to know about program synthesis?

Recently (as of aug 2022), the topic of "building AI to write code" have become fashionable in both industry and academia, with [copilot](https://github.com/features/copilot) making its way to production (if you have not used it, stop reading and try it first). However, program synthesis is much broader than generating few lines of code from comments. Programs are broadly useful in modeling both **computation** and **communication**, and whenever programs exist, program synthesis is sure to follow. This blog series will be a primer to the **modern**, **practical** aspects of program synthesis, so you can have the know-how and confidence to apply it to your own works. I intend to keep the write-ups concise, which will come at a cost of correctness, so I ask you to read pragmatically.

Let's begin.

# what is program?
Programming is the act of a person asking the computer to do something. Examples: Hacking the linux kernel is programming. Creating an email filter is programming. Me setting up this blog is programming.

# why do we program?
We program because computers can help us with difficult tasks. Examples: A human cannot multiplex different programs at 10 GHz. A human cannot sort through 1000s of emails manually. I do not want to deliver the blog to you in mails.

# what is program synthesis?
Program synthesis is the act of building a system that makes programming easier. Examples: GCC frees you from having to write assembly (in the 70s and 80s, program synthesis literally used to mean compilers). Using "filter emails like this" makes creating a filter easier. Jekyll generating the website, pulling in different dependencies makes creating this blog easier. Program synthesis is simply "easier programming" and must be stated in relative terms of the original "harder programming" context.

# why do we program synthesis?
Left as an exercise for the readers.





